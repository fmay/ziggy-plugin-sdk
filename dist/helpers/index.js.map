{"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/helpers/index.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Helper Functions for Plugin Development\n *\n * These helpers delegate to the functions injected into BlockExecutionProps\n * for consistent behavior across core and plugin blocks.\n */\n\nimport { BlockExecutionProps, IFlowEdgeData, IFlowBlock, IFlowEdge, BatchStackProps } from '../types'\n\n/**\n * Formulates a fatal error and sets it on the execution props\n * This will stop flow execution and report the error to the user\n *\n * @param props - Block execution props\n * @param block - Block where error occurred\n * @param msg - Error message or stack trace\n */\nexport function formulateFatalError(\n  props: BlockExecutionProps,\n  block: IFlowBlock,\n  msg: string\n): void {\n  // Delegate to props helper function\n  props.formulateFatalError(block, msg)\n}\n\n/**\n * Prettifies JSON strings found in error messages for better readability\n * @param msg - Error message\n * @returns Prettified message\n */\nfunction prettifyErrorMessage(msg: string): string {\n  try {\n    const jsonPattern = /(\\w+):\\s*(\\{[^{}]*(?:\\{[^{}]*}[^{}]*)*})/g\n    let prettifiedMsg = msg\n    let match: RegExpExecArray | null\n\n    while ((match = jsonPattern.exec(msg)) !== null) {\n      const label = match[1]\n      const jsonString = match[2]\n\n      try {\n        const parsed = JSON.parse(jsonString)\n        const prettified = JSON.stringify(parsed, null, 2)\n        prettifiedMsg = prettifiedMsg.replace(\n          `${label}: ${jsonString}`,\n          `${label}:\\n${prettified}`\n        )\n      } catch {\n        // If parsing fails, leave it as is\n      }\n    }\n\n    return prettifiedMsg\n  } catch {\n    return msg\n  }\n}\n\n/**\n * Helper to get input edge data for a block\n *\n * @param props - Block execution props\n * @param block - The block to get input data for\n * @param inputIndex - Index of the input edge (default 0)\n * @returns Edge data or undefined\n */\nexport function getInputEdgeData(\n  props: BlockExecutionProps,\n  block: IFlowBlock,\n  inputIndex: number = 0\n): IFlowEdgeData | undefined {\n  // Delegate to props helper function\n  return props.getInputEdgeData(block, inputIndex)\n}\n\n/**\n * Assigns data to outgoing edges and adds next blocks to the execution stack\n * This is the standard way to output data from a block\n *\n * @param props - Block execution props\n * @param block - Current block\n * @param edgeIndex - Output edge index (0 for first output, 1 for second, etc.)\n * @param inputEdgeData - Input edge data (for passing through batch info)\n * @param outputEdgeData - Data to send to the next block(s)\n * @param batchItem - optional batchItem data\n * @returns Array of output edges\n */\nexport function outgoingEdgeAssignment(\n  props: BlockExecutionProps,\n  block: IFlowBlock,\n  edgeIndex: number,\n  inputEdgeData: IFlowEdgeData | null,\n  outputEdgeData: any,\n  batchItem?: BatchStackProps | BatchStackProps[],\n): any[] {\n  // Delegate to props helper function\n  return props.outgoingEdgeAssignment(block, edgeIndex, inputEdgeData, outputEdgeData, batchItem)\n}\n\n/**\n * Deep copy helper for safely cloning objects\n *\n * @param obj - Object to clone\n * @returns Deep cloned object\n */\nexport function deepCopy<T>(obj: T): T {\n  if (obj === null || typeof obj !== 'object') return obj\n  if (obj instanceof Date) return new Date(obj.getTime()) as any\n  if (obj instanceof Array) return obj.map(item => deepCopy(item)) as any\n  if (obj instanceof Object) {\n    const copy: any = {}\n    for (const key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        copy[key] = deepCopy(obj[key])\n      }\n    }\n    return copy\n  }\n  return obj\n}\n\n/**\n * Validates that required configuration properties exist\n *\n * @param config - Block configuration object\n * @param requiredProps - Array of required property names\n * @throws Error if required properties are missing\n */\nexport function validateConfig(config: any, requiredProps: string[]): void {\n  // This helper doesn't need props, so we keep the implementation here\n  const missing = requiredProps.filter(prop => !(prop in config))\n  if (missing.length > 0) {\n    throw new Error(`Missing required configuration: ${missing.join(', ')}`)\n  }\n}\n\n/**\n * Safe JSON parse with default value\n *\n * @param str - JSON string to parse\n * @param defaultValue - Default value if parsing fails\n * @returns Parsed object or default value\n */\nexport function safeJsonParse<T>(str: string, defaultValue: T): T {\n  try {\n    return JSON.parse(str)\n  } catch {\n    return defaultValue\n  }\n}\n\n/**\n * Logs a message to the console with block context\n *\n * @param props - Block execution props\n * @param block - Block context\n * @param message - Message to log\n * @param level - Log level (default: 'info')\n */\nexport function logMessage(\n  props: BlockExecutionProps,\n  block: IFlowBlock,\n  message: string,\n  level: 'info' | 'warn' | 'error' | 'debug' = 'info'\n): void {\n  // Delegate to props helper function\n  props.logMessage(block, message, level)\n}\n\n/**\n * Safely waits for input edge data to arrive at a specific input handle\n * Handles flow termination gracefully by returning null if the flow is terminated\n * This is useful for blocks that need to wait for async data arrival\n *\n * @param props - Block execution props\n * @param blockId - The block ID to wait for data on\n * @param handleId - The input handle ID (e.g., 'i0', 'i1')\n * @returns Promise that resolves to edge data if received, null if flow terminated\n *\n * @example\n * const input = await safeWaitForInputEdgeData(props, block.id, 'i0')\n * if (!input) return  // Flow terminated, exit gracefully\n * const payload = input.payload\n */\nexport async function safeWaitForInputEdgeData(\n  props: BlockExecutionProps,\n  blockId: string,\n  handleId: string\n): Promise<IFlowEdgeData | null> {\n  // Delegate to props helper function\n  return await props.safeWaitForInputEdgeData(blockId, handleId)\n}\n\n/**\n * Safely waits for all input edge data to arrive at a block\n * Waits until all incoming edges have data, then returns them sorted by handle (i0, i1, i2, etc.)\n * Handles flow termination gracefully by returning null if the flow is terminated\n * This is useful for blocks that need to merge or process multiple inputs together\n *\n * @param props - Block execution props\n * @param block - The block to wait for all input data on\n * @returns Promise that resolves to array of edge data sorted by input handle, or null if flow terminated\n *\n * @example\n * const inputData = await safeWaitForAllInputEdgeData(props, block)\n * if (!inputData) return  // Flow terminated, exit gracefully\n * const payloads = inputData.map(edge => edge.payload)\n * // payloads[0] is from i0, payloads[1] is from i1, etc.\n */\nexport async function safeWaitForAllInputEdgeData(\n  props: BlockExecutionProps,\n  block: IFlowBlock\n): Promise<IFlowEdgeData[] | null> {\n  // Delegate to props helper function\n  return await props.safeWaitForAllInputEdgeData(block)\n}\n\n/**\n * Gets or creates a batch stack item for the current block\n * Used by blocks that initiate batch processing (Iterator, Loop, etc.)\n * Manages batch iteration counters and state\n *\n * @param props - Block execution props\n * @param block - The block initiating the batch\n * @returns The batch stack properties with iteration state\n *\n * @example\n * const batchItem = getBatchStackItem(props, block)\n * if (batchItem.offset >= config.maxIterations) {\n *   terminateBatch(props, batchItem)\n *   return\n * }\n * batchItem.offset++\n */\nexport function getBatchStackItem(\n  props: BlockExecutionProps,\n  block: IFlowBlock\n): BatchStackProps {\n  // Delegate to props helper function\n  return props.getBatchStackItem(block)\n}\n\n/**\n * Terminates a batch processing loop\n * Removes the batch item from the stack, closes any open streams,\n * and routes execution to blocks after the batch end block\n *\n * @param props - Block execution props\n * @param batchItem - The batch stack properties to terminate\n *\n * @example\n * const data = await fetchBatchData(config, batchItem.offset)\n * if (data.length === 0) {\n *   terminateBatch(props, batchItem)\n *   return\n * }\n */\nexport function terminateBatch(\n  props: BlockExecutionProps,\n  batchItem: BatchStackProps\n): void {\n  // Delegate to props helper function\n  props.terminateBatch(batchItem)\n}\n\n/**\n * Logs block execution time and data metrics\n * Records input/output data array lengths for monitoring and performance tracking\n *\n * @param props - Block execution props\n * @param block - Block being logged\n * @param inEdgeData - Input edge data (can be single edge, array of edges, or raw data arrays)\n * @param outEdges - Output edges (single or array)\n * @param time - Execution time in milliseconds\n * @param isRawInputData - Whether input is raw data arrays vs edge data structures\n *\n * @example\n * const startTime = new Date()\n * // ... block execution logic ...\n * block.data.executionTime = new Date().getTime() - startTime.getTime()\n * logTime(props, block, [inputEdge], outEdges, block.data.executionTime)\n */\nexport function logTime(\n  props: BlockExecutionProps,\n  block: IFlowBlock,\n  inEdgeData: IFlowEdgeData | IFlowEdgeData[] | any[][],\n  outEdges: IFlowEdge | IFlowEdge[],\n  time: number,\n  isRawInputData?: boolean\n): void {\n  // Delegate to props helper function\n  props.logTime(props, block, inEdgeData, outEdges, time, isRawInputData)\n}\n\n/**\n * Checks if a batch should be terminated based on iteration limits and data availability\n * Automatically terminates the batch if conditions are met\n *\n * @param props - Block execution props\n * @param batchItem - The batch stack item to check\n * @param maxIterations - Maximum number of iterations allowed (0 or undefined means no limit)\n * @returns true if batch was terminated, false otherwise\n *\n * @example\n * const batchItem = getBatchStackItem(props, block)\n * if (shouldTerminateBatchHelper(props, batchItem, config.maxIterations)) {\n *   return  // Batch has been terminated, exit block\n * }\n * // Continue processing...\n */\nexport function shouldTerminateBatchHelper(\n  props: BlockExecutionProps,\n  batchItem: BatchStackProps,\n  maxIterations: number,\n): boolean {\n  const iterationsMaxReached = maxIterations && batchItem.iterations >= maxIterations\n  if (batchItem.noMoreData || iterationsMaxReached) {\n    terminateBatch(props, batchItem)\n    return true\n  }\n  return false\n}\n"]}